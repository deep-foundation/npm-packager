{
  "package": {
    "name": "@deep-foundation/npm-packager",
    "version": "0.0.4"
  },
  "data": [
    {
      "package": {
        "dependencyId": 0,
        "containValue": "Type"
      },
      "id": 1
    },
    {
      "package": {
        "dependencyId": 0,
        "containValue": "Any"
      },
      "id": 2
    },
    {
      "package": {
        "dependencyId": 0,
        "containValue": "PackageQuery"
      },
      "id": 3
    },
    {
      "package": {
        "dependencyId": 0,
        "containValue": "SyncTextFile"
      },
      "id": 4
    },
    {
      "package": {
        "dependencyId": 0,
        "containValue": "Handler"
      },
      "id": 5
    },
    {
      "package": {
        "dependencyId": 0,
        "containValue": "HandleInsert"
      },
      "id": 6
    },
    {
      "package": {
        "dependencyId": 0,
        "containValue": "dockerSupportsJs"
      },
      "id": 7
    },
    {
      "package": {
        "dependencyId": 0,
        "containValue": "Package"
      },
      "id": 8
    },
    {
      "package": {
        "dependencyId": 0,
        "containValue": "Value"
      },
      "id": 9
    },
    {
      "package": {
        "dependencyId": 0,
        "containValue": "String"
      },
      "id": 10
    },
    {
      "id": "Install",
      "type": 1,
      "from": 2,
      "to": 3
    },
    {
      "id": "installCode",
      "type": 4,
      "value": {
        "value": "async ({ deep, require, gql, data: { newLink } }) => {\n  const fs = require('fs');\n\n  const makeTempDirectory = () => {\n    const os = require('os');\n    const { v4: uuid } = require('uuid');\n    \n    const baseTempDirectory = os.tmpdir();\n    const randomId = uuid();\n    const tempDirectory = [baseTempDirectory,randomId].join('/');\n    fs.mkdirSync(tempDirectory);\n    console.log(tempDirectory);\n    return tempDirectory;\n  };\n  const npmInstall = (packageName, tempDirectory) => {\n    const execSync = require('child_process').execSync;\n\n    const command = `npm --prefix \"${tempDirectory}\" i ${packageName}`;\n    const output = execSync(command, { \n        encoding: 'utf-8',\n        cwd: tempDirectory\n    });\n    console.log(`${command}\\n`, output);\n    return output;\n  };\n  const makePackagePath = (tempDirectory, packageName) => [tempDirectory, 'node_modules', packageName].join('/');\n  const makeDeepJsonPath = (packagePath) => [packagePath, 'deep.json'].join('/');\n  const makePackageJsonPath = (packagePath) => [packagePath, 'package.json'].join('/');\n  const deepImport = async (pkg) => {\n    const packager = new (require('@deep-foundation/deeplinks/imports/packager')).Packager(deep);\n    const imported = await packager.import(pkg);\n    console.log(imported);\n    if (imported?.errors?.length) throw imported.errors;\n    return imported;\n  };\n\n  const { data: [{ value: { value: packageName } }] } = await deep.select({ id: newLink.to_id });\n  if (!packageName) {\n    throw \"Package query value is empty.\";\n  }\n  const tempDirectory = makeTempDirectory();\n  npmInstall(packageName, tempDirectory);\n  const packagePath = makePackagePath(tempDirectory, packageName);\n  const deepJsonPath = makeDeepJsonPath(packagePath);\n  const packageJsonPath = makePackageJsonPath(packagePath);\n  const deepJson = require(deepJsonPath);\n  const packageJson = require(packageJsonPath);\n  fs.rmSync(tempDirectory, { recursive: true, force: true });\n  if (deepJson.package.name !== packageJson.name) {\n    throw new Error(`Package name is not synchronized between deep.json and package.json files.\ndeep.json package name: ${deepJson.package.name}.\npackage.json package name: ${packageJson.name}.`);\n  }\n  if (deepJson.package.version !== packageJson.version) {\n    throw new Error(`Package version is not synchronized between deep.json and package.json files.\ndeep.json package version: ${deepJson.package.name}.\npackage.json package version: ${packageJson.name}.`);\n  }\n  const imported = await deepImport(deepJson);\n  await deep.insert({\n    type_id: await deep.id('@deep-foundation/core', 'Contain'),\n    from_id: newLink.from_id,\n    to_id: imported.packageId,\n  });\n  return imported;\n}"
      }
    },
    {
      "id": "installCodeHandler",
      "type": 5,
      "from": 7,
      "to": "installCode"
    },
    {
      "id": "installCodeHandleInsert",
      "type": 6,
      "from": "Install",
      "to": "installCodeHandler"
    },
    {
      "id": "Publish",
      "type": 1,
      "from": 8,
      "to": 3
    },
    {
      "id": "publishCode",
      "type": 4,
      "value": {
        "value": "async ({ deep, require, gql, data: { triggeredByLinkId, newLink } }) => {\n  const fs = require('fs');\n  const encoding = 'utf8';\n  \n  const makeTempDirectory = () => {\n    const os = require('os');\n    const { v4: uuid } = require('uuid');\n    \n    const baseTempDirectory = os.tmpdir();\n    const randomId = uuid();\n    const tempDirectory = [baseTempDirectory,randomId].join('/');\n    fs.mkdirSync(tempDirectory);\n    console.log(tempDirectory);\n    return tempDirectory;\n  };\n  const npmInstall = (packageName, installationPath) => {\n    const execSync = require('child_process').execSync;\n  \n    const command = `npm --prefix \"${installationPath}\" i ${packageName}`;\n    try {\n      const output = execSync(command, { \n        encoding: 'utf-8',\n        cwd: installationPath\n      }).toString();\n      console.log(`${command}\\n`, output);\n      return {\n        resolved: {\n          status: 0,\n          stdout: output\n        }\n      };\n    } catch(error) {\n      return {\n        rejected: error\n      };\n    }\n  };\n  const npmLogin = (token, tempDirectory) => {\n    const execSync = require('child_process').execSync;\n  \n    const command = `npm set \"//registry.npmjs.org/:_authToken\" ${token}`;\n    const output = execSync(command, { \n        encoding: 'utf-8',\n        cwd: tempDirectory\n    });\n    console.log(`${command}\\n`, output);\n    return output;\n  };\n  const npmPublish = (tempDirectory) => {\n    const execSync = require('child_process').execSync;\n  \n    const command = `npm publish --access public`;\n    const output = execSync(command, { \n        encoding: 'utf-8',\n        cwd: tempDirectory\n    });\n    console.log(`${command}\\n`, output);\n    return output;\n  };\n  const makeDeepPackagePath = (tempDirectory, packageName) => [tempDirectory, 'node_modules', packageName].join('/');\n  const makeDeepJsonPath = (packagePath) => [packagePath, 'deep.json'].join('/');\n  const makePackageJsonPath = (packagePath) => [packagePath, 'package.json'].join('/');\n  const deepExport = async (packageId) => {\n    const packager = new (require('@deep-foundation/deeplinks/imports/packager')).Packager(deep);\n    const exported = await packager.export({ packageLinkId: packageId });\n    console.log(exported);\n    if (exported?.errors?.length) throw exported.errors;\n    return exported;\n  };\n  const loadNpmToken = async () => {\n    const containTreeId = await deep.id('@deep-foundation/core', 'containTree');\n    const tokenTypeId = await deep.id('@deep-foundation/npm-packager', 'Token');\n    const { data: [{ value: { value: npmToken }}]} = await deep.select({\n      up: {\n        tree_id: { _eq: containTreeId },\n        parent: { id: { _eq: triggeredByLinkId } },\n        link: { type_id: { _eq: tokenTypeId } }\n      }\n    });\n    return npmToken;\n  };\n  const updateVersion = async (packageJsonPath, packageId) => {\n    const semver = require('semver');\n\n    const packageJson = fs.readFileSync(packageJsonPath, { encoding });\n    if (!packageJson) {\n      throw 'package.json is not found in installed package';\n    }\n    const npmPackage = JSON.parse(packageJson);\n    const nextVersion = npmPackage.version = semver.inc(npmPackage?.version || '0.0.0', 'patch');\n    \n    // TODO: Not sure about this.\n    // TODO: Should we update the version inside deep?\n    // TODO: May be we would allow to user to set specific version \n    // TODO: if they like or only they can interpret changes in code?\n    await deep.update({\n      link: {\n        type_id: { _eq: await deep.id('@deep-foundation/core', 'PackageVersion') },\n        to_id: { _eq: packageId },\n      },\n    }, { value: nextVersion }, { table: 'strings' });\n    fs.writeFileSync(packageJsonPath, JSON.stringify(npmPackage, null, 2), { encoding });\n  };\n  const installDependencies = (packagePath, dependencies) => {\n    for (const dependency of dependencies) {\n      const packageName = `${dependency.name}@^${dependency.version}`;\n      const installationResult = npmInstall(packageName, packagePath);\n      if (installationResult?.rejected) {\n        throw installationResult.rejected;\n      } else if (!installationResult?.resolved) {\n        throw new Error('Unsupported NPM dependency installation result.');\n      }\n    }\n  }\n\n  const { data: [packageQuery] } = await deep.select({ id: newLink.to_id });\n  const packageName = packageQuery?.value?.value;\n  if (!packageName) {\n    throw new Error('Package query value is empty.');\n  }\n  const packageId = newLink.from_id;  \n  const { data: [{ value: actualPackageName }]} = await deep.select(\n    { link_id: { _eq: packageId } },\n    {\n      table: 'strings',\n      returning: 'value'\n    }\n  );\n  if (packageName !== actualPackageName) {\n    throw new Error('Package query value should be equal to actual package name.');\n  }\n  const tempDirectory = makeTempDirectory();\n  const installationResult = npmInstall(packageName, tempDirectory);\n  let deepPackagePath; \n  let packageJsonPath;\n  if (installationResult?.resolved) {\n    deepPackagePath = makeDeepPackagePath(tempDirectory, packageName);\n    packageJsonPath = makePackageJsonPath(deepPackagePath);\n  } else if(installationResult?.rejected) {\n    deepPackagePath = tempDirectory;\n    packageJsonPath = makePackageJsonPath(deepPackagePath);\n    const packageJson = {\n      name: packageName\n    };\n    fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2), encoding);\n  } else {\n    throw new Error('Unsupported NPM installation result.');\n  }\n  console.log('deepPackagePath', deepPackagePath);\n  console.log('packageJsonPath', packageJsonPath);\n  await updateVersion(packageJsonPath, packageId);\n  const pkg = await deepExport(packageId);\n  console.log(pkg);\n  installDependencies(deepPackagePath, pkg.dependencies);\n  const deepJsonPath = makeDeepJsonPath(deepPackagePath);\n  fs.writeFileSync(deepJsonPath, JSON.stringify(pkg, null, 2), encoding);\n  const npmToken = await loadNpmToken();\n  npmLogin(npmToken, deepPackagePath);\n  npmPublish(deepPackagePath);\n  fs.rmSync(tempDirectory, { recursive: true, force: true });\n}"
      }
    },
    {
      "id": "publishCodeHandler",
      "type": 5,
      "from": 7,
      "to": "publishCode"
    },
    {
      "id": "publishCodeHandleInsert",
      "type": 6,
      "from": "Publish",
      "to": "publishCodeHandler"
    },
    {
      "id": "Token",
      "type": 1
    },
    {
      "id": "tokenValue",
      "type": 9,
      "from": "Token",
      "to": 10
    },
    {
      "id": "Used",
      "type": 1,
      "from": "Install",
      "to": 8
    },
    {
      "id": "Installed",
      "type": 1,
      "from": "Install",
      "to": 8
    }
  ],
  "errors": [],
  "dependencies": [
    {
      "name": "@deep-foundation/core",
      "version": "0.0.1"
    }
  ]
}